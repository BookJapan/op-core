<?php/** * Blowfish encrypt/decrypt *  * Other language * http://www.schneier.com/blowfish-download.html *  * @version   1.0 * @author    Tomoaki Nagahara <tomoaki.nagahara@gmail.com> * @copyright 2006 (C) Tomoaki Nagahara All right reserved. */class Blowfish{		private $cipher = null;	private $mode   = null;	private $key    = null;	private $pad    = null;		function Init()	{		if( empty($this->cipher) ){			$this->SetCipher();		}				if( empty($this->mode) ){			$this->SetMode();		}				if( empty($this->key) ){			$this->SetKey();		}				if( empty($this->pad) ){			$this->SetPad();		}				return array( $this->cipher, $this->mode, $this->key, $this->pad );	}		function SetCipher($cipher='BLOWFISH')	{		switch( strtoupper($cipher) ){			default:			case 'BLOWFISH':				$this->cipher = MCRYPT_BLOWFISH;				break;		}	}		function SetMode($mode='CBC')	{		switch( strtoupper($mode) ){			case 'ECB':				$this->mode = MCRYPT_MODE_ECB;				break;							default:			case 'CBC':				$this->mode = MCRYPT_MODE_CBC;				break;		}	}		function SetKey( $hex='04B915BA43FEB5B6' )	{		//if( preg_match('/[^0-9a-f]+/i', $hex, $match) ){		if(!ctype_xdigit($hex) ){ // Check the hexadecimal			$this->StackError("Is this hex string? ({$match[0]}). Use ConvertHex($hex) method.");			return false;		}		$this->key = pack('H*', $hex);	}		function SetPad( $pad=false )	{		$this->pad = $pad ? true: false;	}		function Encrypt( $data )	{		list( $cipher, $mode, $key, $pad ) = $this->init();				if( empty($key) ){			$this->StackError("Does not initialized secret key.");			return false;		}				// Padding block size		if( $pad ){	    	$size = mcrypt_get_block_size( $cipher, $mode );	    	$data = $this->pkcs5_pad($data, $size);		}				srand();		$ivs = mcrypt_get_iv_size($cipher,$mode);		$iv  = mcrypt_create_iv( $ivs, MCRYPT_RAND ); // Windows is only MCRYPT_RAND.		$bin = mcrypt_encrypt( $cipher, $key, $data, $mode, $iv );		$hex = bin2hex($bin);			    return bin2hex($iv).bin2hex($bin);	}		function Decrypt( $str )	{		list( $cipher, $mode, $key, $pad ) = $this->init();				//	required "IV"		//list( $ivt, $hex ) = explode( '.', $str );				//  head 16byte is initial vector		$ivt = substr( $str, 0, 16 );		$hex = substr( $str, 16 );				//	check		if( !$hex or !$ivt or !$key ){			return '';		}				//  unpack		$bin = pack('H*', $hex);		$iv  = pack('H*', $ivt);	    $dec = mcrypt_decrypt( $cipher, $key, $bin, $mode, $iv );	    	    //  remove padding	    if( $pad ){	    	$size = mcrypt_get_block_size( $cipher, $mode );			$data = $this->pkcs5_unpad($dec, $size);		}else{			$data = rtrim($dec, "\0");		}	    	    return $data;	}			function pkcs5_pad ($text, $blocksize)	{	    $pad = $blocksize - (strlen($text) % $blocksize);	    return $text . str_repeat(chr($pad), $pad);	}	function pkcs5_unpad($text)	{	    $pad = ord($text{strlen($text)-1});	    if ($pad > strlen($text)) return false;	    if (strspn($text, chr($pad), strlen($text) - $pad) != $pad) return false;	    return substr($text, 0, -1 * $pad);	}}